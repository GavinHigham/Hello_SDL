local util = {}
local gl_unsafe = require 'OpenGL'
local gl_safe
local gl = gl_unsafe

--[[
You can do this to receive a "safe" wrapper around OpenGL, and enable within this module:
local util, gl = require 'util'.safe()
]]
local knownerrors = {
	DrawArraysInstanced = {
		GL_INVALID_ENUM = 'GL_INVALID_ENUM is generated if mode is not one of the accepted values.',
		GL_INVALID_OPERATION = [[
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object.
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.]],
		GL_INVALID_VALUE = 'GL_INVALID_VALUE is generated if count or instancecount is negative.',
	},
	DrawElementsInstanced = {
		GL_INVALID_ENUM = 'GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, or GL_TRIANGLES.',
		GL_INVALID_VALUE = 'GL_INVALID_VALUE is generated if count or instancecount is negative.',
		GL_INVALID_OPERATION = [[
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object.
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.]],
	},
	VertexAttribPointer = {
		GL_INVALID_VALUE = [[
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.'
GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
GL_INVALID_VALUE is generated if stride is negative.]],
		GL_INVALID_ENUM = 'GL_INVALID_ENUM is generated if type is not an accepted value.',
		GL_INVALID_OPERATION = [[
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.]],
	}
}

function util.safeWrapFunc(f, fname)
	if not fname then fname = tostring(f) end
	return function(...)
		if util.print_gl_calls then print(fname);print(...) end
		--Call the function with pcall (in case of runtime error) and store return values
		local returnvals = table.pack(pcall(f, ...))
		--Re-throw error from level 2 to use the right callstack position for the error message
		if not returnvals[1] then
			error(returnvals[2], 2)
		end
		local errorcode = gl.GetError()
		if errorcode ~= 0 then
			--Throw OpenGL errors as Lua errors (again, level 2)
			--See if we have a potentially useful error message to tack on
			local extraerror = (knownerrors[fname] and knownerrors[fname][errorcode])
			if extraerror then extraerror = '\n'..extraerror else extraerror = '' end
			error('OpenGL error '..errorcode..extraerror, 2)
		end
		--Discard status code from pcall and return all other original return values
		return select(2, table.unpack(returnvals))
	end
end

util.print_gl_calls = false
function util.safe()
	if not gl_safe then
		gl_safe = {}
		for k,v in pairs(gl) do
			if type(v) == 'function' and k ~= 'GetError' then
				--Wrap all gl functions such that they call gl.GetError() afterwards
				gl_safe[k] = util.safeWrapFunc(v, k)
			else
				gl_safe[k] = v
			end
		end
	end
	gl = gl_safe
	return util, gl_safe
end

function util.unsafe()
	gl = gl_unsafe
	return util, gl_unsafe
end

--This comment was grabbed from proctri_scene.lua, I think I forgot that I had duplicated stuff into circlegraph_scene.lua
	--[[
VAO is an object that represents the binding between the current buffer and the current attribute indices. A particular buffer holding interleaved vertex data may not work with a different shader, if that other shader does not assign the "same" attributes to the same attribute index. I can force them using glBindAttribLocation

--Attributes can be specified as argument to VertexData constructor
VertexData('vec3 color, float time')

	--Can also call attributes() directly
	.attributes 'vec3 color, float time'
	--Vertex buffer is provided as interleaved
	.vertices {
		1.0, 0.0, 0.0,  0.0,
		0.0, 1.0, 0.0,  0.5,
		0.0, 0.0, 1.0,  1.0}
	--Index buffer is self-explanatory
	.indices {0, 1, 2}
	--Adjacency index buffer is optional, only used by particular draw methods
	.adjacency {--[=[example adjacency index buffer to go here]=]}
]]

--Hacky implementation of a tiny part of the GLSW library, to work with shaders I have already using this pattern.
function util.glsw(shader)
	--Support passing an open file handle instead of a string, as a convenience
	if io.type(shader) == 'file' then shader = shader:read('a') end
	local matches = {}
	local i,j,match,j_prev,match_prev = nil,nil
	repeat
		i,j,match = shader:find('%s*%-%-%s*([%w%.]*).-\n', (j or 0)+1)
		if match_prev then
			matches[match_prev] = shader:sub(j_prev+1, (i or 0)-1)
		end
		j_prev, match_prev = j, match
	until not match
	return matches
end

return util